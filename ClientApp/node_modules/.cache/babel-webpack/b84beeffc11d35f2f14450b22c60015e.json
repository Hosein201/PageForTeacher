{"ast":null,"code":"// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Rellax = factory();\n  }\n})(typeof window !== \"undefined\" ? window : global, function () {\n  var Rellax = function Rellax(el, options) {\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true; // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n\n    var loop = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) {\n      return setTimeout(callback, 1000 / 60);\n    }; // store the id for later use\n\n\n    var loopId = null; // Test via a getter in the options object to see if the passive property is accessed\n\n    var supportsPassive = false;\n\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {} // check what cancelAnimation method to use\n\n\n    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout; // check which transform property to use\n\n    var transformProp = window.transformProp || function () {\n      var testEl = document.createElement('div');\n\n      if (testEl.style.transform === null) {\n        var vendors = ['Webkit', 'Moz', 'ms'];\n\n        for (var vendor in vendors) {\n          if (testEl.style[vendors[vendor] + 'Transform'] !== undefined) {\n            return vendors[vendor] + 'Transform';\n          }\n        }\n      }\n\n      return 'transform';\n    }(); // Default Settings\n\n\n    self.options = {\n      speed: -2,\n      verticalSpeed: null,\n      horizontalSpeed: null,\n      breakpoints: [576, 768, 1201],\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      verticalScrollAxis: \"y\",\n      horizontalScrollAxis: \"x\",\n      callback: function callback() {}\n    }; // User defined options (might have more in the future)\n\n    if (options) {\n      Object.keys(options).forEach(function (key) {\n        self.options[key] = options[key];\n      });\n    }\n\n    function validateCustomBreakpoints() {\n      if (self.options.breakpoints.length === 3 && Array.isArray(self.options.breakpoints)) {\n        var isAscending = true;\n        var isNumerical = true;\n        var lastVal;\n        self.options.breakpoints.forEach(function (i) {\n          if (typeof i !== 'number') isNumerical = false;\n\n          if (lastVal !== null) {\n            if (i < lastVal) isAscending = false;\n          }\n\n          lastVal = i;\n        });\n        if (isAscending && isNumerical) return;\n      } // revert defaults if set incorrectly\n\n\n      self.options.breakpoints = [576, 768, 1201];\n      console.warn(\"Rellax: You must pass an array of 3 numbers in ascending order to the breakpoints option. Defaults reverted\");\n    }\n\n    if (options && options.breakpoints) {\n      validateCustomBreakpoints();\n    } // By default, rellax class\n\n\n    if (!el) {\n      el = '.rellax';\n    } // check if el is a className or a node\n\n\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el]; // Now query selector\n\n    if (elements.length > 0) {\n      self.elems = elements;\n    } // The elements don't exist\n    else {\n        console.warn(\"Rellax: The elements you're trying to select don't exist.\");\n        return;\n      } // Has a wrapper and it exists\n\n\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          console.warn(\"Rellax: The wrapper you're trying to use doesn't exist.\");\n          return;\n        }\n      }\n    } // set a placeholder for the current breakpoint\n\n\n    var currentBreakpoint; // helper to determine current breakpoint\n\n    var getCurrentBreakpoint = function getCurrentBreakpoint(w) {\n      var bp = self.options.breakpoints;\n      if (w < bp[0]) return 'xs';\n      if (w >= bp[0] && w < bp[1]) return 'sm';\n      if (w >= bp[1] && w < bp[2]) return 'md';\n      return 'lg';\n    }; // Get and cache initial position of all elements\n\n\n    var cacheBlocks = function cacheBlocks() {\n      for (var i = 0; i < self.elems.length; i++) {\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    }; // Let's kick this script off\n    // Build array for cached element values\n\n\n    var init = function init() {\n      for (var i = 0; i < blocks.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      currentBreakpoint = getCurrentBreakpoint(screenX);\n      setPosition();\n      cacheBlocks();\n      animate(); // If paused, unpause and set listener for window resizing events\n\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false; // Start the loop\n\n        update();\n      }\n    }; // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n\n\n    var createBlock = function createBlock(el) {\n      var dataPercentage = el.getAttribute('data-rellax-percentage');\n      var dataSpeed = el.getAttribute('data-rellax-speed');\n      var dataXsSpeed = el.getAttribute('data-rellax-xs-speed');\n      var dataMobileSpeed = el.getAttribute('data-rellax-mobile-speed');\n      var dataTabletSpeed = el.getAttribute('data-rellax-tablet-speed');\n      var dataDesktopSpeed = el.getAttribute('data-rellax-desktop-speed');\n      var dataVerticalSpeed = el.getAttribute('data-rellax-vertical-speed');\n      var dataHorizontalSpeed = el.getAttribute('data-rellax-horizontal-speed');\n      var dataVericalScrollAxis = el.getAttribute('data-rellax-vertical-scroll-axis');\n      var dataHorizontalScrollAxis = el.getAttribute('data-rellax-horizontal-scroll-axis');\n      var dataZindex = el.getAttribute('data-rellax-zindex') || 0;\n      var dataMin = el.getAttribute('data-rellax-min');\n      var dataMax = el.getAttribute('data-rellax-max');\n      var dataMinX = el.getAttribute('data-rellax-min-x');\n      var dataMaxX = el.getAttribute('data-rellax-max-x');\n      var dataMinY = el.getAttribute('data-rellax-min-y');\n      var dataMaxY = el.getAttribute('data-rellax-max-y');\n      var mapBreakpoints;\n      var breakpoints = true;\n\n      if (!dataXsSpeed && !dataMobileSpeed && !dataTabletSpeed && !dataDesktopSpeed) {\n        breakpoints = false;\n      } else {\n        mapBreakpoints = {\n          'xs': dataXsSpeed,\n          'sm': dataMobileSpeed,\n          'md': dataTabletSpeed,\n          'lg': dataDesktopSpeed\n        };\n      } // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n\n\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n      var posY = self.options.vertical ? dataPercentage || self.options.center ? wrapperPosY : 0 : 0;\n      var posX = self.options.horizontal ? dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft : 0 : 0;\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth; // apparently parallax equation everyone uses\n\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n\n      if (self.options.center) {\n        percentageX = 0.5;\n        percentageY = 0.5;\n      } // Optional individual block speed as data attr, otherwise global speed\n\n\n      var speed = breakpoints && mapBreakpoints[currentBreakpoint] !== null ? Number(mapBreakpoints[currentBreakpoint]) : dataSpeed ? dataSpeed : self.options.speed;\n      var verticalSpeed = dataVerticalSpeed ? dataVerticalSpeed : self.options.verticalSpeed;\n      var horizontalSpeed = dataHorizontalSpeed ? dataHorizontalSpeed : self.options.horizontalSpeed; // Optional individual block movement axis direction as data attr, otherwise gobal movement direction\n\n      var verticalScrollAxis = dataVericalScrollAxis ? dataVericalScrollAxis : self.options.verticalScrollAxis;\n      var horizontalScrollAxis = dataHorizontalScrollAxis ? dataHorizontalScrollAxis : self.options.horizontalScrollAxis;\n      var bases = updatePosition(percentageX, percentageY, speed, verticalSpeed, horizontalSpeed); // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n\n      var style = el.style.cssText;\n      var transform = ''; // Check if there's an inline styled transform\n\n      var searchResult = /transform\\s*:/i.exec(style);\n\n      if (searchResult) {\n        // Get the index of the transform\n        var index = searchResult.index; // Trim the style to the transform point and get the following semi-colon index\n\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';'); // Remove \"transform\" string and save the attribute\n\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g, '');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g, '');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        verticalSpeed: verticalSpeed,\n        horizontalSpeed: horizontalSpeed,\n        verticalScrollAxis: verticalScrollAxis,\n        horizontalScrollAxis: horizontalScrollAxis,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax,\n        minX: dataMinX,\n        maxX: dataMaxX,\n        minY: dataMinY,\n        maxY: dataMaxY\n      };\n    }; // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n\n\n    var setPosition = function setPosition() {\n      var oldY = posY;\n      var oldX = posX;\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset; // If option relativeToWrapper is true, use relative wrapper value instead.\n\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      } // scroll did not change\n\n\n      return false;\n    }; // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n\n\n    var updatePosition = function updatePosition(percentageX, percentageY, speed, verticalSpeed, horizontalSpeed) {\n      var result = {};\n      var valueX = (horizontalSpeed ? horizontalSpeed : speed) * (100 * (1 - percentageX));\n      var valueY = (verticalSpeed ? verticalSpeed : speed) * (100 * (1 - percentageY));\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n      return result;\n    }; // Remove event listeners and loop again\n\n\n    var deferredUpdate = function deferredUpdate() {\n      window.removeEventListener('resize', deferredUpdate);\n      window.removeEventListener('orientationchange', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate); // loop again\n\n      loopId = loop(update);\n    }; // Loop\n\n\n    var update = function update() {\n      if (setPosition() && pause === false) {\n        animate(); // loop again\n\n        loopId = loop(update);\n      } else {\n        loopId = null; // Don't animate until we get a position updating event\n\n        window.addEventListener('resize', deferredUpdate);\n        window.addEventListener('orientationchange', deferredUpdate);\n        (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? {\n          passive: true\n        } : false);\n        (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? {\n          passive: true\n        } : false);\n      }\n    }; // Transform3d on parallax element\n\n\n    var animate = function animate() {\n      var positions;\n\n      for (var i = 0; i < self.elems.length; i++) {\n        // Determine relevant movement directions\n        var verticalScrollAxis = blocks[i].verticalScrollAxis.toLowerCase();\n        var horizontalScrollAxis = blocks[i].horizontalScrollAxis.toLowerCase();\n        var verticalScrollX = verticalScrollAxis.indexOf(\"x\") != -1 ? posY : 0;\n        var verticalScrollY = verticalScrollAxis.indexOf(\"y\") != -1 ? posY : 0;\n        var horizontalScrollX = horizontalScrollAxis.indexOf(\"x\") != -1 ? posX : 0;\n        var horizontalScrollY = horizontalScrollAxis.indexOf(\"y\") != -1 ? posX : 0;\n        var percentageY = (verticalScrollY + horizontalScrollY - blocks[i].top + screenY) / (blocks[i].height + screenY);\n        var percentageX = (verticalScrollX + horizontalScrollX - blocks[i].left + screenX) / (blocks[i].width + screenX); // Subtracting initialize value, so element stays in same spot as HTML\n\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed, blocks[i].verticalSpeed, blocks[i].horizontalSpeed);\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX; // The next two \"if\" blocks go like this:\n        // Check if a limit is defined (first \"min\", then \"max\");\n        // Check if we need to change the Y or the X\n        // (Currently working only if just one of the axes is enabled)\n        // Then, check if the new position is inside the allowed limit\n        // If so, use new position. If not, set position to limit.\n        // Check if a min limit is defined\n\n        if (blocks[i].min !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;\n          }\n\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;\n          }\n        } // Check if directional min limits are defined\n\n\n        if (blocks[i].minY != null) {\n          positionY = positionY <= blocks[i].minY ? blocks[i].minY : positionY;\n        }\n\n        if (blocks[i].minX != null) {\n          positionX = positionX <= blocks[i].minX ? blocks[i].minX : positionX;\n        } // Check if a max limit is defined\n\n\n        if (blocks[i].max !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;\n          }\n\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;\n          }\n        } // Check if directional max limits are defined\n\n\n        if (blocks[i].maxY != null) {\n          positionY = positionY >= blocks[i].maxY ? blocks[i].maxY : positionY;\n        }\n\n        if (blocks[i].maxX != null) {\n          positionX = positionX >= blocks[i].maxX ? blocks[i].maxX : positionX;\n        }\n\n        var zindex = blocks[i].zindex; // Move that element\n        // (Set the new translation and append initial inline transforms.)\n\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n\n      self.options.callback(positions);\n    };\n\n    self.destroy = function () {\n      for (var i = 0; i < self.elems.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      } // Remove resize event listener if not pause, and pause\n\n\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      } // Clear the animation loop to prevent possible memory leak\n\n\n      clearLoop(loopId);\n      loopId = null;\n    }; // Init\n\n\n    init(); // Allow to recalculate the initial values whenever we want\n\n    self.refresh = init;\n    return self;\n  };\n\n  return Rellax;\n});","map":{"version":3,"sources":["E:/githup/now-ui-kit-angular-master/now-ui-kit-angular-master/node_modules/rellax/rellax.js"],"names":["root","factory","define","amd","module","exports","Rellax","window","global","el","options","self","Object","create","prototype","posY","screenY","posX","screenX","blocks","pause","loop","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","oRequestAnimationFrame","callback","setTimeout","loopId","supportsPassive","opts","defineProperty","get","addEventListener","removeEventListener","e","clearLoop","cancelAnimationFrame","mozCancelAnimationFrame","clearTimeout","transformProp","testEl","document","createElement","style","transform","vendors","vendor","undefined","speed","verticalSpeed","horizontalSpeed","breakpoints","center","wrapper","relativeToWrapper","round","vertical","horizontal","verticalScrollAxis","horizontalScrollAxis","keys","forEach","key","validateCustomBreakpoints","length","Array","isArray","isAscending","isNumerical","lastVal","i","console","warn","elements","querySelectorAll","elems","nodeType","querySelector","currentBreakpoint","getCurrentBreakpoint","w","bp","cacheBlocks","block","createBlock","push","init","cssText","innerHeight","innerWidth","setPosition","animate","update","dataPercentage","getAttribute","dataSpeed","dataXsSpeed","dataMobileSpeed","dataTabletSpeed","dataDesktopSpeed","dataVerticalSpeed","dataHorizontalSpeed","dataVericalScrollAxis","dataHorizontalScrollAxis","dataZindex","dataMin","dataMax","dataMinX","dataMaxX","dataMinY","dataMaxY","mapBreakpoints","wrapperPosY","scrollTop","pageYOffset","documentElement","body","scrollPosY","offsetTop","scrollLeft","pageXOffset","blockTop","getBoundingClientRect","top","blockHeight","clientHeight","offsetHeight","scrollHeight","blockLeft","left","blockWidth","clientWidth","offsetWidth","scrollWidth","percentageY","percentageX","Number","bases","updatePosition","searchResult","exec","index","trimmedStyle","slice","delimiter","indexOf","replace","baseX","x","baseY","y","height","width","zindex","min","max","minX","maxX","minY","maxY","oldY","oldX","parentNode","result","valueX","valueY","Math","deferredUpdate","passive","positions","toLowerCase","verticalScrollX","verticalScrollY","horizontalScrollX","horizontalScrollY","positionY","positionX","translate","destroy","refresh"],"mappings":"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","sourcesContent":["\n// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Rellax = factory();\n  }\n}(typeof window !== \"undefined\" ? window : global, function () {\n  var Rellax = function(el, options){\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true;\n\n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      function(callback){ return setTimeout(callback, 1000 / 60); };\n\n    // store the id for later use\n    var loopId = null;\n\n    // Test via a getter in the options object to see if the passive property is accessed\n    var supportsPassive = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function() {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {}\n\n    // check what cancelAnimation method to use\n    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;\n\n    // check which transform property to use\n    var transformProp = window.transformProp || (function(){\n        var testEl = document.createElement('div');\n        if (testEl.style.transform === null) {\n          var vendors = ['Webkit', 'Moz', 'ms'];\n          for (var vendor in vendors) {\n            if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {\n              return vendors[vendor] + 'Transform';\n            }\n          }\n        }\n        return 'transform';\n      })();\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n\t    verticalSpeed: null,\n\t    horizontalSpeed: null,\n      breakpoints: [576, 768, 1201],\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      verticalScrollAxis: \"y\",\n      horizontalScrollAxis: \"x\",\n      callback: function() {},\n    };\n\n    // User defined options (might have more in the future)\n    if (options){\n      Object.keys(options).forEach(function(key){\n        self.options[key] = options[key];\n      });\n    }\n\n    function validateCustomBreakpoints () {\n      if (self.options.breakpoints.length === 3 && Array.isArray(self.options.breakpoints)) {\n        var isAscending = true;\n        var isNumerical = true;\n        var lastVal;\n        self.options.breakpoints.forEach(function (i) {\n          if (typeof i !== 'number') isNumerical = false;\n          if (lastVal !== null) {\n            if (i < lastVal) isAscending = false;\n          }\n          lastVal = i;\n        });\n        if (isAscending && isNumerical) return;\n      }\n      // revert defaults if set incorrectly\n      self.options.breakpoints = [576, 768, 1201];\n      console.warn(\"Rellax: You must pass an array of 3 numbers in ascending order to the breakpoints option. Defaults reverted\");\n    }\n\n    if (options && options.breakpoints) {\n      validateCustomBreakpoints();\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    // check if el is a className or a node\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don't exist\n    else {\n      console.warn(\"Rellax: The elements you're trying to select don't exist.\");\n      return;\n    }\n\n    // Has a wrapper and it exists\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          console.warn(\"Rellax: The wrapper you're trying to use doesn't exist.\");\n          return;\n        }\n      }\n    }\n\n    // set a placeholder for the current breakpoint\n    var currentBreakpoint;\n\n    // helper to determine current breakpoint\n    var getCurrentBreakpoint = function (w) {\n      var bp = self.options.breakpoints;\n      if (w < bp[0]) return 'xs';\n      if (w >= bp[0] && w < bp[1]) return 'sm';\n      if (w >= bp[1] && w < bp[2]) return 'md';\n      return 'lg';\n    };\n\n    // Get and cache initial position of all elements\n    var cacheBlocks = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    };\n\n\n    // Let's kick this script off\n    // Build array for cached element values\n    var init = function() {\n      for (var i = 0; i < blocks.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      currentBreakpoint = getCurrentBreakpoint(screenX);\n\n      setPosition();\n\n      cacheBlocks();\n\n      animate();\n\n      // If paused, unpause and set listener for window resizing events\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false;\n        // Start the loop\n        update();\n      }\n    };\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function(el) {\n      var dataPercentage = el.getAttribute( 'data-rellax-percentage' );\n      var dataSpeed = el.getAttribute( 'data-rellax-speed' );\n      var dataXsSpeed = el.getAttribute( 'data-rellax-xs-speed' );\n      var dataMobileSpeed = el.getAttribute( 'data-rellax-mobile-speed' );\n      var dataTabletSpeed = el.getAttribute( 'data-rellax-tablet-speed' );\n      var dataDesktopSpeed = el.getAttribute( 'data-rellax-desktop-speed' );\n      var dataVerticalSpeed = el.getAttribute('data-rellax-vertical-speed');\n      var dataHorizontalSpeed = el.getAttribute('data-rellax-horizontal-speed');\n      var dataVericalScrollAxis = el.getAttribute('data-rellax-vertical-scroll-axis');\n      var dataHorizontalScrollAxis = el.getAttribute('data-rellax-horizontal-scroll-axis');\n      var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;\n      var dataMin = el.getAttribute( 'data-rellax-min' );\n      var dataMax = el.getAttribute( 'data-rellax-max' );\n      var dataMinX = el.getAttribute('data-rellax-min-x');\n      var dataMaxX = el.getAttribute('data-rellax-max-x');\n      var dataMinY = el.getAttribute('data-rellax-min-y');\n      var dataMaxY = el.getAttribute('data-rellax-max-y');\n      var mapBreakpoints;\n      var breakpoints = true;\n\n      if (!dataXsSpeed && !dataMobileSpeed && !dataTabletSpeed && !dataDesktopSpeed) {\n        breakpoints = false;\n      } else {\n        mapBreakpoints = {\n          'xs': dataXsSpeed,\n          'sm': dataMobileSpeed,\n          'md': dataTabletSpeed,\n          'lg': dataDesktopSpeed\n        };\n      }\n\n      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n      var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;\n      var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;\n\n      // apparently parallax equation everyone uses\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n      if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = (breakpoints && mapBreakpoints[currentBreakpoint] !== null) ? Number(mapBreakpoints[currentBreakpoint]) : (dataSpeed ? dataSpeed : self.options.speed);\n      var verticalSpeed = dataVerticalSpeed ? dataVerticalSpeed : self.options.verticalSpeed;\n      var horizontalSpeed = dataHorizontalSpeed ? dataHorizontalSpeed : self.options.horizontalSpeed;\n\n      // Optional individual block movement axis direction as data attr, otherwise gobal movement direction\n      var verticalScrollAxis = dataVericalScrollAxis ? dataVericalScrollAxis : self.options.verticalScrollAxis;\n      var horizontalScrollAxis = dataHorizontalScrollAxis ? dataHorizontalScrollAxis : self.options.horizontalScrollAxis;\n\n      var bases = updatePosition(percentageX, percentageY, speed, verticalSpeed, horizontalSpeed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = '';\n\n      // Check if there's an inline styled transform\n      var searchResult = /transform\\s*:/i.exec(style);\n      if (searchResult) {\n        // Get the index of the transform\n        var index = searchResult.index;\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';');\n\n        // Remove \"transform\" string and save the attribute\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g,'');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g,'');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        verticalSpeed: verticalSpeed,\n        horizontalSpeed: horizontalSpeed,\n        verticalScrollAxis: verticalScrollAxis,\n        horizontalScrollAxis: horizontalScrollAxis,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax,\n        minX: dataMinX,\n        maxX: dataMaxX,\n        minY: dataMinY,\n        maxY: dataMaxY\n      };\n    };\n\n    // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function() {\n      var oldY = posY;\n      var oldX = posX;\n\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n      // If option relativeToWrapper is true, use relative wrapper value instead.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n    var updatePosition = function(percentageX, percentageY, speed, verticalSpeed, horizontalSpeed) {\n      var result = {};\n      var valueX = ((horizontalSpeed ? horizontalSpeed : speed) * (100 * (1 - percentageX)));\n      var valueY = ((verticalSpeed ? verticalSpeed : speed) * (100 * (1 - percentageY)));\n\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n\n      return result;\n    };\n\n    // Remove event listeners and loop again\n    var deferredUpdate = function() {\n      window.removeEventListener('resize', deferredUpdate);\n      window.removeEventListener('orientationchange', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate);\n\n      // loop again\n      loopId = loop(update);\n    };\n\n    // Loop\n    var update = function() {\n      if (setPosition() && pause === false) {\n        animate();\n\n        // loop again\n        loopId = loop(update);\n      } else {\n        loopId = null;\n\n        // Don't animate until we get a position updating event\n        window.addEventListener('resize', deferredUpdate);\n        window.addEventListener('orientationchange', deferredUpdate);\n        (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? { passive: true } : false);\n        (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? { passive: true } : false);\n      }\n    };\n\n    // Transform3d on parallax element\n    var animate = function() {\n      var positions;\n      for (var i = 0; i < self.elems.length; i++){\n        // Determine relevant movement directions\n        var verticalScrollAxis = blocks[i].verticalScrollAxis.toLowerCase();\n        var horizontalScrollAxis = blocks[i].horizontalScrollAxis.toLowerCase();\n        var verticalScrollX = verticalScrollAxis.indexOf(\"x\") != -1 ? posY : 0;\n        var verticalScrollY = verticalScrollAxis.indexOf(\"y\") != -1 ? posY : 0;\n        var horizontalScrollX = horizontalScrollAxis.indexOf(\"x\") != -1 ? posX : 0;\n        var horizontalScrollY = horizontalScrollAxis.indexOf(\"y\") != -1 ? posX : 0;\n\n        var percentageY = ((verticalScrollY + horizontalScrollY - blocks[i].top + screenY) / (blocks[i].height + screenY));\n        var percentageX = ((verticalScrollX + horizontalScrollX - blocks[i].left + screenX) / (blocks[i].width + screenX));\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed, blocks[i].verticalSpeed, blocks[i].horizontalSpeed);\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX;\n\n        // The next two \"if\" blocks go like this:\n        // Check if a limit is defined (first \"min\", then \"max\");\n        // Check if we need to change the Y or the X\n        // (Currently working only if just one of the axes is enabled)\n        // Then, check if the new position is inside the allowed limit\n        // If so, use new position. If not, set position to limit.\n\n        // Check if a min limit is defined\n        if (blocks[i].min !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;\n          }\n        }\n\n        // Check if directional min limits are defined\n        if (blocks[i].minY != null) {\n            positionY = positionY <= blocks[i].minY ? blocks[i].minY : positionY;\n        }\n        if (blocks[i].minX != null) {\n            positionX = positionX <= blocks[i].minX ? blocks[i].minX : positionX;\n        }\n\n        // Check if a max limit is defined\n        if (blocks[i].max !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;\n          }\n        }\n\n        // Check if directional max limits are defined\n        if (blocks[i].maxY != null) {\n            positionY = positionY >= blocks[i].maxY ? blocks[i].maxY : positionY;\n        }\n        if (blocks[i].maxX != null) {\n            positionX = positionX >= blocks[i].maxX ? blocks[i].maxX : positionX;\n        }\n\n        var zindex = blocks[i].zindex;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(positions);\n    };\n\n    self.destroy = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      // Remove resize event listener if not pause, and pause\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      }\n\n      // Clear the animation loop to prevent possible memory leak\n      clearLoop(loopId);\n      loopId = null;\n    };\n\n    // Init\n    init();\n\n    // Allow to recalculate the initial values whenever we want\n    self.refresh = init;\n\n    return self;\n  };\n  return Rellax;\n}));\n"]},"metadata":{},"sourceType":"script"}